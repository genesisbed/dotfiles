diff --git a/src/main.c b/src/main.c
index 970eaec..b57b634 100644
--- a/src/main.c
+++ b/src/main.c
@@ -147,11 +147,6 @@ static void render(struct display_output *output) {
         {MPV_RENDER_PARAM_INVALID, NULL},
     };
 
-    if (!eglMakeCurrent(egl_display, output->egl_surface, output->egl_surface, egl_context))
-        cflp_error("Failed to make output surface current 0x%X", eglGetError());
-
-    glViewport(0, 0, output->width * output->scale, output->height * output->scale);
-
     // Render frame
     int mpv_err = mpv_render_context_render(mpv_glcontext, render_params);
     if (mpv_err < 0)
@@ -579,8 +574,9 @@ static void init_mpv(const struct wl_state *state) {
     mpv_render_context_set_update_callback(mpv_glcontext, render_update_callback, NULL);
 }
 
-static void init_egl(struct wl_state *state) {
-    egl_display = eglGetPlatformDisplay(EGL_PLATFORM_WAYLAND_KHR, state->display, NULL);
+static void init_egl(struct display_output *output) {
+    output->egl_window = wl_egl_window_create(output->surface, output->width * output->scale, output->height * output->scale);
+    egl_display = eglGetPlatformDisplay(EGL_PLATFORM_WAYLAND_KHR, output->state->display, NULL);
     if (!eglInitialize(egl_display, NULL, NULL)) {
         cflp_error("Failed to initialize EGL 0x%X", eglGetError());
         exit_mpvpaper(EXIT_FAILURE);
@@ -627,15 +623,23 @@ static void init_egl(struct wl_state *state) {
         exit_mpvpaper(EXIT_FAILURE);
     }
 
-    if (!eglMakeCurrent(egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, egl_context)) {
-        cflp_error("Failed to make context current 0x%X", eglGetError());
-        exit_mpvpaper(EXIT_FAILURE);
+    output->egl_surface = eglCreatePlatformWindowSurface(egl_display, egl_config, output->egl_window, NULL);
+    if (!output->egl_surface) {
+        cflp_error("Failed to create EGL surface for %s 0x%X", output->name, eglGetError());
     }
 
+    if (!eglMakeCurrent(egl_display, output->egl_surface, output->egl_surface, egl_context))
+        cflp_error("Failed to make output surface current 0x%X", eglGetError());
+        
+    eglSwapInterval(egl_display, 0);
+
     if (!gladLoadGLLoader((GLADloadproc)eglGetProcAddress)) {
         cflp_error("Failed to load OpenGL 0x%X", eglGetError());
         exit_mpvpaper(EXIT_FAILURE);
     }
+
+    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+    glViewport(0, 0, output->width * output->scale, output->height * output->scale);
 }
 
 static void destroy_display_output(struct display_output *output) {
@@ -669,7 +673,7 @@ static void layer_surface_configure(void *data, struct zwlr_layer_surface_v1 *su
     // Setup render loop
     struct wl_state *state = output->state;
     if (!egl_display) {
-        init_egl(state);
+        init_egl(output);
         if (VERBOSE)
             cflp_success("EGL initialized");
     }
@@ -681,20 +685,6 @@ static void layer_surface_configure(void *data, struct zwlr_layer_surface_v1 *su
     }
 
     if (!output->egl_window) {
-        output->egl_window = wl_egl_window_create(output->surface, output->width * output->scale, output->height * output->scale);
-        output->egl_surface = eglCreatePlatformWindowSurface(egl_display, egl_config, output->egl_window, NULL);
-        if (!output->egl_surface) {
-            cflp_error("Failed to create EGL surface for %s 0x%X", output->name, eglGetError());
-            destroy_display_output(output);
-            return;
-        }
-
-        if (!eglMakeCurrent(egl_display, output->egl_surface, output->egl_surface, egl_context))
-            cflp_error("Failed to make output surface current 0x%X", eglGetError());
-        eglSwapInterval(egl_display, 0);
-
-        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
-
         // Start render loop
         if (VERBOSE)
             cflp_success("%s setup is complete and is ready to start rendering", output->name);
@@ -1081,58 +1071,26 @@ int main(int argc, char **argv) {
         return EXIT_FAILURE;
     }
 
+
     // Main Loop
     while (true) {
         if (wl_display_flush(state.display) == -1 && errno != EAGAIN)
             break;
 
-        struct pollfd fds[2];
-        fds[0].fd = wl_display_get_fd(state.display);
-        fds[0].events = POLLIN;
-        fds[1].fd = wakeup_pipe[0];
-        fds[1].events = POLLIN;
-
-        // Wait for MPV to request a new frame to be drawn
-        int poll_err = 0;
-        while (poll_err == 0) {
-            poll_err = poll(fds, sizeof(fds) / sizeof(fds[0]), 10);  // 10ms timeout
-            if (poll_err == -1 && errno != EINTR)
-                break;
-
-            if (halt_info.stop_render_loop) {
-                halt_info.stop_render_loop = 0;
-                sleep(2); // Wait at least 2 secs to be killed
-            }
-        }
-
-        if (fds[0].revents & POLLIN) {
-            if (wl_display_dispatch(state.display) == -1)
-                break;
-        }
-
-        // MPV is ready to draw a new frame
-        if (fds[1].revents & POLLIN) {
-            // Empty the pipe
-            char tmp[64];
-            if (read(wakeup_pipe[0], tmp, sizeof(tmp)) == -1)
-                break;
+        if (wl_display_dispatch(state.display) == -1)
+            break;
 
-            mpv_render_context_update(mpv_glcontext);
-
-            // Draw frame for all outputs
-            struct display_output *output;
-            wl_list_for_each(output, &state.outputs, link) {
-                // Redraw immediately if not waiting for frame callback
-                if (output->frame_callback == NULL) {
-                    // Avoid crash when output is destroyed 
-                    if (output->egl_window && output->egl_surface) {
-                        if (VERBOSE == 2)
-                            cflp_info("MPV is ready to render the next frame for %s", output->name);
-                        render(output);
-                    }
-                } else {
-                    output->redraw_needed = true;
-                }
+        mpv_render_context_update(mpv_glcontext);
+
+        // Draw frame for all outputs
+        struct display_output *output;
+        wl_list_for_each(output, &state.outputs, link) {
+            // Redraw immediately if not waiting for frame callback
+            if (output->frame_callback == NULL) {
+                if (output->egl_window && output->egl_surface)
+                    render(output);
+            } else {
+                output->redraw_needed = true;
             }
         }
     }
